<pre>    /**
     * The Async interface of the service
     */
    interface FakeRpcServiceAsync
    {
        void getNewData( AsyncCallback&lt;DataPoint[]&gt; callback );
    }

    /**
     * Plot
     */
    @UiField( provided = true )
    SimplePlot plot;

    /**
     * Button Start & Stop
     */
    @UiField
    Button startStop;

    /**
     * Timer
     */
    private Timer updater;

    /**
     * Create plot
     */
    public Widget createPlot()
    {
        PlotModel model = new PlotModel();
        PlotOptions plotOptions = PlotOptions.create();
        plotOptions.setGlobalSeriesOptions( GlobalSeriesOptions.create()
            .setLineSeriesOptions( LineSeriesOptions.create().setLineWidth( 1 ).setShow( true ).setFill( true ) )
            .setPointsOptions( PointsSeriesOptions.create().setRadius( 2 ).setShow( true ) ).setShadowSize( 0d ) );
        plotOptions.addXAxisOptions( AxisOptions.create().setShow( false ) );

        final SeriesHandler series =
            model.addSeries( Series.of( "Random Series", "#003366" ), PlotModelStrategy.downSamplingStrategy( 20 ) );

        // pull the "fake" RPC service for new data
        updater = new Timer() {
            @Override
            public void run()
            {
                update( series, plot );
            }
        };

        // create the plot
        plot = new SimplePlot( model, plotOptions );

        return binder.createAndBindUi( this );
    }

    /**
     * Start the timer when the activity starts
     */
    @Override
    public void start( AcceptsOneWidget panel, EventBus eventBus )
    {
        super.start( panel, eventBus );
        start();
    }

    /**
     * Stop the timer when the activity stops
     */
    @Override
    public void onStop()
    {
        stop();
        super.onStop();
    }

    /**
     * On click on the start/stop button
     */
    @UiHandler( "startStop" )
    void onClickStartStop( ClickEvent e )
    {
        if ( "Stop".equals( startStop.getText() ) )
        {
            stop();
        }
        else
        {
            start();
        }
    }

    /**
     * Start the timer
     */
    private void start()
    {
        startStop.setText( "Stop" );
        updater.scheduleRepeating( 1000 );
    }

    /**
     * Stop the timer
     */
    private void stop()
    {
        startStop.setText( "Start" );
        updater.cancel();
    }

    /**
     * Fake a rpc call and update the data
     */
    private void update( final SeriesHandler series, final PlotWidget plot )
    {
        FakeRpcServiceAsync service = getRpcService();
        service.getNewData( new AsyncCallback&lt;DataPoint[]&gt;() {
            public void onFailure( Throwable caught )
            {
                GWT.log( "Something went wrong", caught );
            }

            public void onSuccess( DataPoint[] result )
            {
                for ( DataPoint dataPoint : result )
                {
                    series.add( dataPoint );
                }
                plot.redraw();
            }
        } );
    }

    /**
     * @return a fake rpc service
     */
    private FakeRpcServiceAsync getRpcService()
    {
        return new FakeRpcServiceAsync() {
            public void getNewData( final AsyncCallback&lt;DataPoint[]&gt; callback )
            {
                double up = Random.nextDouble();
                double down = Random.nextDouble();
                callback.onSuccess( new DataPoint[] { DataPoint.of( timeCounter++, previous - down ),
                    DataPoint.of( timeCounter++, previous + up ) } );
                previous = previous + up;
            }
        };
    }

</pre>